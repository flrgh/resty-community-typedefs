---@meta

--- https://github.com/zmartzone/lua-resty-openidc/
---
---@class resty.openidc
---
---@field _VERSION string
local openidc = {}

---@class resty.openidc.opts : table
---
--- The full redirect URI must be protected by this script if the URI starts with a `/` the full redirect URI becomes `ngx.var.scheme.."://"..ngx.var.http_host..opts.redirect_uri` unless the scheme was overridden using `opts.redirect_uri_scheme` or an X-Forwarded-Proto header in the incoming request
---@field redirect_uri string
---
-- The discovery endpoint of the OP. Enable to get the URI of all endpoints (Token, introspection, logout...)
---@field discovery string
---
-- Access to OP Token endpoint requires an authentication. Several authentication modes are supported.
---@field token_endpoint_auth_method "client_secret_basic"|"client_secret_post"|"private_key_jwt"|"client_secret_jwt"
---
--- If token_endpoint_auth_method is set to "client_secret_basic", "client_secret_post", or "client_secret_jwt", authentication to Token endpoint is using client_id and client_secret. For non compliant OPs to OAuth 2.0 RFC 6749 for client Authentication (cf. https://tools.ietf.org/html/rfc6749#section-2.3.1), client_id and client_secret MUST be invariant when url encoded
---@field client_id string
---@field client_secret string
---
--- If token_endpoint_auth_method is set to "private_key_jwt" authentication to Token endpoint is using client_id, client_rsa_private_key and client_rsa_private_key_id to compute a signed JWT. client_rsa_private_key is the RSA private key to be used to sign the JWT generated by lua-resty-openidc for authentication to the OP
---@field client_rsa_private_key string
---
--- client_rsa_private_key_id (optional) is the key id to be set in the JWT header to identify which public key the OP shall use to verify the JWT signature
---@field client_rsa_private_key_id string
---
--- Life duration expressed in seconds of the signed JWT generated by lua-resty-openidc for authentication to the OP. (used when token_endpoint_auth_method is set to "private_key_jwt" or "client_secret_jwt" authentication). Default is 60 seconds.
---@field client_jwt_assertion_expires_in number
---
--- When using https to any OP endpoints, enforcement of SSL certificate check can be mandated ("yes") or not ("no").
---@field ssl_verify "yes"|"no"
---
--- Connection keepalive with the OP can be enabled ("yes") or disabled ("no").
---@field keepalive "yes"|"no"
---
--- Can be used to make lua-resty-openidc use the [OAuth 2.0 Form Post Response Mode](https://openid.net/specs/oauth-v2-form-post-response-mode-1_0.html). *Note* for modern browsers you will need to set [`$session_cookie_samesite`](https://github.com/bungle/lua-resty-session#string-sessioncookiesamesite) to `None` with form_post unless your OpenID Connect Provider and Relying Party share the same domain.
---@field response_mode "form_post"|nil
---
---@field authorization_params table
---
---@field scope string
---
---
--- Refresh the users id_token after 900 seconds without requiring re-authentication
---@field refresh_session_interval number
---
---
---@field iat_slack number
---
---@field redirect_uri_scheme string
---
---@field logout_path string
---
--- Where should the user be redirected after logout from the RP. This option overides any end_session_endpoint that the OP may have provided in the discovery response.
---@field redirect_after_logout_uri string
---
--- Whether the redirection after logout should include the id token as an hint (if available). This option is used only if redirect_after_logout_uri is set.
---@field redirect_after_logout_with_id_token_hint boolean
---
--- Where does the RP requests that the OP redirects the user after logout. If this option is set to a relative URI, it will be relative to the OP's logout endpoint, not the RP's.
---@field post_logout_redirect_uri string
---
---
--- If your OpenID Connect Provider doesn't sign its id tokens (uses the "none" signature algorithm) then set this to true.
---@field accept_none_alg boolean
---
---
--- If you want to reject tokens signed using an algorithm not supported by lua-resty-jwt set this to false. If you leave it unset or set it to true, the token signature will not be verified when an unsupported algorithm is used.
---@field accept_unsupported_alg boolean
---
--- Whether this plugin shall try to silently renew the access token once it is expired if a refresh token is available. if it fails to renew the token, the user will be redirected to the authorization endpoint.
---@field renew_access_token_on_expiry boolean
---
--- Default lifetime in seconds of the access_token if no expires_in attribute is present in the token endpoint response.
---@field access_token_expires_in number
---
--- Expiration leeway for access_token renewal. If this is set, renewal will happen access_token_expires_leeway seconds before the token expiration. This avoids errors in case the access_token just expires when arriving to the OAuth Resource Server.
---@field access_token_expires_leeway number
---
-- When force_reauthorize is set to true the authorization flow will be executed even if a token has been cached already
---@field force_reauthorize boolean
--
-- Whitelist of session content to enable. This can be used to reduce the session size. When not set everything will be included in the session. Available are: id_token, enc_id_token, user, access_token (includes refresh token)
---@field session_contents { id_token:boolean?, enc_id_token:boolean?, user:boolean?, access_token:boolean? }
---
--- You can specify timeouts for connect/send/read as a single number (setting all timeouts) or as a table. Values are in milliseconds
---@field timeout number|{ connect:number, send:number, read:number }
---
---
--- By default the authorization request includes the nonce paramter. You can use this option to disable it which may be necessary when talking to a broken OpenID Connect provider that ignores the paramter as the id_token will be rejected otherwise.
---@field use_nonce boolean
---
---
--- When revoke_tokens_on_logout is set to true a logout notifies the authorization server that previously obtained refresh and access tokens are no longer needed. This requires that revocation_endpoint is discoverable. If there is no revocation endpoint supplied or if there are errors on revocation the user will not be notified and the logout process continues normally.
---@field revoke_tokens_on_logout boolean
---
--- Use outgoing proxy to the OpenID Connect provider endpoints with the proxy_opts table :
---@field proxy_opts { http_proxy: string, https_proxy: string }
---
---
---@field lifecycle table<resty.openidc.lifecycle.event, resty.openidc.lifecycle.hook>
---
---
--- Add decorator for HTTP request that is applied when lua-resty-openidc talks to the OpenID Connect provider directly. Can be used to provide extra HTTP headers or add other similar behavior.
---```lua
--- http_request_decorator = function(req)
---   local h = req.headers or {}
---   h[EXTRA_HEADER] = 'my extra header'
---   req.headers = h
---   return req
--- end,
---```
---@field http_request_decorator fun(req:resty.http.request.params)
---
--- When set to true the "Proof Key for Code Exchange" as defined in RFC 7636 will be used. The code challenge method will alwas be S256
---@field use_pkce boolean
---
--- Whether to pass cookies from the current request to any underlying `call_token_endpoint()` call
---@field pass_cookies boolean
---
---@field symmetric_key string
---
---@field public_key string
---
--- The signature algorithm that you expect has been used; can be a single string or a table. You should set this for security reasons in order to avoid accepting a token claiming to be signed by HMAC using a public RSA key.
---@field token_signing_alg_values_expected string[]
---
--- the expiration time in seconds for jwk cache, default is 1 day.
---@field jwk_expires_in number
---
--- It may be necessary to force verification for a bearer token and ignore the existing cached verification results. If so you need to set set the jwt_verification_cache_ignore option to true.
---@field jwt_verification_cache_ignore boolean
---
--- optional name of a cache-segment if you need separate caches for differently configured locations
---@field cache_segment string
---
--- Defaults to "exp" - Controls the TTL of the introspection cache https://tools.ietf.org/html/rfc7662#section-2.2
---@field introspection_expiry_claim string
---
---
---@field introspection_endpoint string
---
--- Defines the interval in seconds after which a cached and introspected access token needs to be refreshed by introspecting (and validating) it again against the Authorization Server. When not defined the value is 0, which means it only expires after the `exp` (or alternative, see introspection_expiry_claim) hint as returned by the Authorization Server
---@field introspection_interval number
---
--- Defines the way in which bearer OAuth 2.0 access tokens can be passed to this Resource Server.
--- "cookie" as a cookie header called "PA.global" or using the name specified after ":"
--- "header" "Authorization: bearer" header
--- When not defined the default "Authorization: bearer" header is used
---@field auth_accept_token_as string
---
--- If header is used header field is Authorization
---@field auth_accept_token_as_header_name string
---
--- Defaults to "client_secret_post"
---@field introspection_endpoint_auth_method string
---
---@field introspection_cache_ignore boolean


--- Lifecycle Hooks
--
--- lifecycle = {
---    on_created = handle_created,
---    on_authenticated = handle_authenticated,
---    on_regenerated = handle_regenerated
---    on_logout = handle_logout
--- }
--
--- where `handle_created`, `handle_authenticated`, `handle_regenerated` and `handle_logout` are callables
--- accepting a single argument `session`
--
---  -- `on_created` hook is invoked *after* a session has been created in
---     `openidc_authorize` immediately prior to saving the session
---  -- `on_authenticated` hook is invoked *after* receiving authorization response in
---     `openidc_authorization_response` immediately prior to saving the session
---     Starting with lua-resty-openidc 1.7.5 this receives the decoded id_token as second and the response of the token endpoint as third argument
---  -- `on_regenerated` is invoked immediately after the
---       a new access token has been obtained via token
---       refresh and is called with the regenerated session table
---  -- `on_logout` hook is invoked *before* a session is destroyed in
---     `openidc_logout`
--
---  Any, all or none of the hooks may be used. Empty `lifecycle` does nothing.
---  A hook that returns a truthy value causes the lifecycle action they are taking part of to fail.
---
---@alias resty.openidc.lifecycle.event
---| "on_created"                     # hook is invoked *after* a session has been created in `openidc_authorize` immediately prior to saving the session
---| "on_authenticated"               # hook is invoked *after* receiving authorization response in
---| "openidc_authorization_response" # immediately prior to saving the session. Starting with lua-resty-openidc 1.7.5 this receives the decoded id_token as second and the response of the token endpoint as third argument
---| "on_regenerated"                 # is invoked immediately after the a new access token has been obtained via token refresh and is called with the regenerated session table
---| "on_logout"                      # hook is invoked *before* a session is destroyed in `openidc_logout`

--- Lifecycle Hooks
--
--- lifecycle = {
---    on_created = handle_created,
---    on_authenticated = handle_authenticated,
---    on_regenerated = handle_regenerated
---    on_logout = handle_logout
--- }
--
--- where `handle_created`, `handle_authenticated`, `handle_regenerated` and `handle_logout` are callables
--- accepting a single argument `session`
--
---  -- `on_created` hook is invoked *after* a session has been created in
---     `openidc_authorize` immediately prior to saving the session
---  -- `on_authenticated` hook is invoked *after* receiving authorization response in
---     `openidc_authorization_response` immediately prior to saving the session
---     Starting with lua-resty-openidc 1.7.5 this receives the decoded id_token as second and the response of the token endpoint as third argument
---  -- `on_regenerated` is invoked immediately after the
---       a new access token has been obtained via token
---       refresh and is called with the regenerated session table
---  -- `on_logout` hook is invoked *before* a session is destroyed in
---     `openidc_logout`
--
---  Any, all or none of the hooks may be used. Empty `lifecycle` does nothing.
---  A hook that returns a truthy value causes the lifecycle action they are taking part of to fail.
---
---@alias resty.openidc.lifecycle.hook fun(session:any):any


--- make a call to the token endpoint
---
---@param opts                    resty.openidc.opts
---@param endpoint                string
---@param body?                   table
---@param auth?                   string
---@param endpoint_name?          string
---@param ignore_body_on_success? boolean
---
---@return table?  response
---@return string? error
function openidc.call_token_endpoint(opts, endpoint, body, auth, endpoint_name, ignore_body_on_success) end


---@param  opts         resty.openidc.opts
---@param  access_token string
---@return table?       response
---@return string?      error
function openidc.call_userinfo_endpoint(opts, access_token) end


---@param  opts    resty.openidc.opts
---@return string? discovery
---@return string? error
function openidc.get_discovery_doc(opts) end


---@param  opts             resty.openidc.opts
---@param  token_type_hint? string
---@param  token            string
---@return boolean          success
function openidc.revoke_token(opts, token_type_hint, token) end


---@param  opts    resty.openidc.opts
---@param  session table
---@return boolean success
function openidc.revoke_tokens(opts, session) end


---@param opts            resty.openidc.opts
---@param target_url?     string
---@param unauth_action   string
---@param session_or_opts table
---
---@return { id_token:string, access_token:string, user:string }?
---@return string? error
---@return string? target_url
---@return table?  session
function openidc.authenticate(opts, target_url, unauth_action, session_or_opts) end


--- get a valid access_token (eventually refreshing the token), or nil if there's no valid access_token
---
---@param  opts         resty.openidc.opts
---@param  session_opts table
---@return string?      token
---@return string?      error
function openidc.access_token(opts, session_opts) end


--- main routine for OAuth 2.0 token introspection
---
---@param opts resty.openidc.opts
---@return table? data
---@return string? error
function openidc.introspect(opts) end


---@param opts resty.openidc.opts
---@param ... any
---
---@return table?  jwt
---@return string? error
---@return string? access_token
function openidc.bearer_jwt_verify(opts, ...) end


-- main routine for OAuth 2.0 JWT token validation
-- optional args are claim specs, see jwt-validators in resty.jwt
---
---@param access_token string
---@param opts         resty.openidc.opts
---@param ...          any
---
---@return table?  jwt
---@return string? error
---@return string? access_token
function openidc.jwt_verify(access_token, opts, ...) end


---@param new_log? function
---@param new_levels? table
function openidc.set_logging(new_log, new_levels) end


function openidc.invalidate_caches() end


return openidc
